<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxitema | Vanilla Texture Semantic Analyzer</title>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="voxitema_logo.png">
    <!-- Minecraft Font -->
    <link href="https://fonts.cdnfonts.com/css/minecraft-4" rel="stylesheet">
    
    <style>
        :root {
            --mc-bg: #000;
            --mc-gui: #c6c6c6;
            --mc-border-light: #fff;
            --mc-border-dark: #555;
            --mc-gold: #ffaa00;
            --mc-green: #55ff55;
        }

        * { box-sizing: border-box; image-rendering: pixelated; }

        body {
            background-color: var(--mc-bg);
            font-family: 'Minecraft', sans-serif;
            margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center;
            color: #fff; min-height: 100vh;
        }

        /* --- Clickable Header (Replicating Image) --- */
        header { 
            width: 100%; padding: 40px 20px; text-align: center;
            background: #000; cursor: pointer; border-bottom: 2px solid #222;
        }
        .title-row { display: flex; align-items: center; justify-content: center; gap: 20px; }
        .app-logo { width: 72px; height: 72px; }
        .title-text { font-size: 3.5rem; color: var(--mc-gold); text-shadow: 5px 5px 0px #3f3f3f; margin: 0; }
        .subtitle-text { color: #888; font-size: 0.8rem; letter-spacing: 4px; text-transform: uppercase; margin-top: 8px; }

        /* --- Search & Upload --- */
        .controls {
            display: flex; flex-wrap: wrap; justify-content: center;
            gap: 15px; padding: 30px; width: 100%; max-width: 900px;
        }
        .btn-mc {
            background: #707070; border: 4px solid #000; color: #fff;
            padding: 12px 25px; cursor: pointer; position: relative;
            box-shadow: inset -4px -4px 0 #373737, inset 4px 4px 0 #ababab;
            font-family: 'Minecraft', sans-serif; font-size: 1rem;
        }
        .btn-mc:hover { background: #8b8b8b; }
        .btn-mc input { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }

        .search-box {
            background: #000; border: 3px solid #555; color: #fff;
            padding: 12px; font-family: 'Minecraft', sans-serif; width: 350px;
            box-shadow: inset 3px 3px 0 #111; outline: none; font-size: 1rem;
        }

        /* --- Grid & Card Design --- */
        #resultsGrid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(420px, 1fr));
            gap: 25px; width: 95%; max-width: 1800px; padding: 20px;
        }

        .card {
            background: var(--mc-gui); border: 4px solid #000;
            box-shadow: inset -4px -4px 0 var(--mc-border-dark), inset 4px 4px 0 var(--mc-border-light);
            padding: 20px; display: flex; flex-direction: column; gap: 15px;
        }

        .card-header {
            display: flex; align-items: center; gap: 20px;
            padding-bottom: 12px; border-bottom: 2px solid #a1a1a1;
        }

        .img-frame {
            background: #8b8b8b; border: 3px solid #373737; padding: 4px;
            box-shadow: inset 3px 3px 0 #000; width: 64px; height: 64px; flex-shrink: 0;
        }
        .img-frame img { width: 100%; height: 100%; }

        .item-name { font-size: 1.1rem; color: #000; text-transform: uppercase; font-weight: bold; }

        /* --- Hex Color Slots --- */
        .color-slot { margin-top: 5px; }
        .label-text { font-size: 0.6rem; color: #707070; font-weight: bold; text-transform: uppercase; margin-bottom: 4px; }

        .hex-box {
            background: #000; border: 1.5px solid #373737; position: relative;
            cursor: pointer; height: 50px; display: flex; justify-content: center; align-items: center;
        }
        .hex-value { color: var(--mc-gold); font-size: 1.6rem; letter-spacing: 1px; }
        .color-stripe { position: absolute; bottom: 0; left: 0; width: 100%; height: 6px; border-top: 1px solid #222; }

        #toast {
            position: fixed; bottom: 30px; background: #000; color: var(--mc-green);
            border: 2px solid var(--mc-green); padding: 15px 30px; display: none; z-index: 1000;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <header onclick="location.reload()">
        <div class="header-content">
            <div class="title-row">
                <img src="voxitema_logo.png" class="app-logo" alt="">
                <h1 class="title-text">VOXITEMA</h1>
            </div>
            <div class="subtitle-text">VANILLA TEXTURE SEMANTIC ANALYZER</div>
        </div>
    </header>

    <div class="controls">
        <div class="btn-mc">IMPORT ASSETS<input type="file" id="fileInput" multiple accept="image/*"></div>
        <input type="text" id="searchInput" class="search-box" placeholder="Find texture by name...">
    </div>

    <div id="resultsGrid"></div>
    <div id="toast">HEX COPIED</div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const searchInput = document.getElementById('searchInput');
        const resultsGrid = document.getElementById('resultsGrid');

        // Instant Filter Search
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toUpperCase();
            document.querySelectorAll('.card').forEach(card => {
                card.classList.toggle('hidden', !card.getAttribute('data-name').includes(query));
            });
        });

        fileInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            for (const file of files) {
                const name = file.name.split('.').slice(0, -1).join('.').replace(/_/g, ' ').toUpperCase();
                await processFile(file, name);
            }
        });

        async function processFile(file, name) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const palette = analyzeTexture(img, name);
                        renderCard(name, e.target.result, palette);
                        resolve();
                    };
                };
            });
        }

        function analyzeTexture(img, name) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // ANTI-CRASH: Limit math to a 32x32 sample grid
            const s = 32;
            canvas.width = s; canvas.height = s;
            ctx.drawImage(img, 0, 0, s, s);
            const data = ctx.getImageData(0, 0, s, s).data;

            // Logic to determine if asset is a "Simple Item" or a "Complex Block"
            const itemKeywords = ["SHARD", "INGOT", "SWORD", "PICKAXE", "AXE", "SHOVEL", "HOE", "APPLE", "DUST", "NUGGET", "RAW", "CRYSTAL", "POTION", "BOOK"];
            const blockKeywords = ["BLOCK", "ORE", "DEBRIS", "BULB", "VAULT", "SPAWNER", "COMMAND", "CRAFTER", "BRICK"];
            
            const isItem = itemKeywords.some(k => name.includes(k));
            const isComplexBlock = blockKeywords.some(k => name.includes(k));

            // items and simple textures (Wool/Shulker) get ONE color average
            if (isItem || (!isComplexBlock && name.length > 0)) {
                // If it contains block keywords but is a side/top variant, check further
                const isVariant = name.includes("SIDE") || name.includes("TOP") || name.includes("BOTTOM");
                if (isItem && !isVariant) return [getAverageHex(data)];
                
                // If it's a known simple block (Wool/Leaves), also force 1 color
                if (["WOOL", "LEAVES", "GLASS", "SHULKER", "DIRT", "GRASS"].some(k => name.includes(k))) {
                    return [getAverageHex(data)];
                }
            }

            // Multi-Color extraction for complex blocks (Ores, Bulbs, etc.)
            let clusters = {};
            let redDot = null;

            for (let i = 0; i < data.length; i += 4) {
                const [r, g, b, a] = [data[i], data[i+1], data[i+2], data[i+3]];
                if (a < 128) continue;
                if (r > 160 && g < 75 && b < 75) redDot = rgbToHex(r, g, b); // Redstone signal detect

                const key = `${Math.round(r/15)*15},${Math.round(g/15)*15},${Math.round(b/15)*15}`;
                clusters[key] = (clusters[key] || 0) + 1;
            }

            const sorted = Object.entries(clusters).sort((a, b) => b[1] - a[1]);
            let results = [];
            if (sorted[0]) results.push(rgbToHex(...sorted[0][0].split(',').map(Number)));

            for (let i = 1; i < sorted.length && results.length < 3; i++) {
                const hex = rgbToHex(...sorted[i][0].split(',').map(Number));
                if (!isSimilar(hex, results, 70)) results.push(hex);
            }

            if (redDot && !isSimilar(redDot, results, 60)) results.push(redDot);
            return results;
        }

        function getAverageHex(data) {
            let r=0, g=0, b=0, c=0;
            for (let i=0; i<data.length; i+=4) {
                if (data[i+3] < 128) continue;
                r += data[i]; g += data[i+1]; b += data[i+2]; c++;
            }
            return c ? rgbToHex(Math.round(r/c), Math.round(g/c), Math.round(b/c)) : "#000000";
        }

        function isSimilar(h, arr, thresh) {
            return arr.some(ex => {
                const c1 = hexToRgb(h); const c2 = hexToRgb(ex);
                return (Math.abs(c1.r-c2.r) + Math.abs(c1.g-c2.g) + Math.abs(c1.b-c2.b)) < thresh;
            });
        }

        function rgbToHex(r, g, b) { return "#" + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('').toUpperCase(); }
        function hexToRgb(hex) { const n = parseInt(hex.slice(1), 16); return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 }; }

        function renderCard(name, src, colors) {
            let labels = ["PRIMARY SURFACE", "ACCENT DETAIL", "SECONDARY DETAIL"];
            
            // Context Labels based on your provided screenshots
            if (name.includes("ORE") || name.includes("DEBRIS")) {
                labels = ["STONE BASE", "ORE OVERLAY", "DETAIL"];
            } else if (name.includes("BULB")) {
                labels = ["BLOCK TEXTURE COLOR", "BULB LIGHT COLOR", "SIGNAL COLOR"];
            } else if (colors.length === 1) {
                // FORCE ACCENT DETAIL FOR ITEMS
                labels = ["ACCENT DETAIL"];
            }

            const html = colors.map((hex, i) => `
                <div class="color-slot">
                    <div class="label-text">${labels[i] || "DETAIL"}</div>
                    <div class="hex-box" onclick="copyToClipboard('${hex}')">
                        <span class="hex-value">${hex}</span>
                        <div class="color-stripe" style="background-color: ${hex}"></div>
                    </div>
                </div>
            `).join('');

            const card = document.createElement('div');
            card.className = 'card';
            card.setAttribute('data-name', name);
            card.innerHTML = `<div class="card-header"><div class="img-frame"><img src="${src}"></div><div class="item-name">${name}</div></div>${html}`;
            resultsGrid.prepend(card);
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text);
            const t = document.getElementById('toast');
            t.style.display = 'block';
            setTimeout(() => t.style.display = 'none', 1000);
        }
    </script>
</body>
</html>